import Affine "../../src/ec/Affine";
import Curves "../../src/ec/Curves";
import TestUtils "../TestUtils";
import Debug "mo:base/Debug";

let curve = Curves.secp256k1;
let Fp = curve.Fp;

type FromBytesTestCase = {
  coords : ?(Nat, Nat);
  data : [Nat8];
};

type ToBytesTestCase = {
  coords : ?(Nat, Nat);
  compressed : [Nat8];
  uncompressed : [Nat8];
};

let toBytesTestCases : [ToBytesTestCase] = [
  {
    // Infinity.
    coords = null;
    compressed = [];
    uncompressed = [];
  },
  {
    // Odd.
    coords = ?(
      0x79be667ef9dcbbac55a06295ce870b07029bfcdb2dce28d959f2815b16f81798,
      0xb7c52588d95c3b9aa25b0403f1eef75702e84bb7597aabe663b82f6f04ef2777,
    );
    compressed = [
      0x03, 0x79, 0xbe, 0x66, 0x7e, 0xf9, 0xdc, 0xbb, 0xac, 0x55, 0xa0, 0x62,
      0x95, 0xce, 0x87, 0x0b, 0x07, 0x02, 0x9b, 0xfc, 0xdb, 0x2d, 0xce, 0x28,
      0xd9, 0x59, 0xf2, 0x81, 0x5b, 0x16, 0xf8, 0x17, 0x98
    ];
    uncompressed = [
      0x04, 0x79, 0xbe, 0x66, 0x7e, 0xf9, 0xdc, 0xbb, 0xac, 0x55, 0xa0, 0x62,
      0x95, 0xce, 0x87, 0x0b, 0x07, 0x02, 0x9b, 0xfc, 0xdb, 0x2d, 0xce, 0x28,
      0xd9, 0x59, 0xf2, 0x81, 0x5b, 0x16, 0xf8, 0x17, 0x98, 0xb7, 0xc5, 0x25,
      0x88, 0xd9, 0x5c, 0x3b, 0x9a, 0xa2, 0x5b, 0x04, 0x03, 0xf1, 0xee, 0xf7,
      0x57, 0x02, 0xe8, 0x4b, 0xb7, 0x59, 0x7a, 0xab, 0xe6, 0x63, 0xb8, 0x2f,
      0x6f, 0x04, 0xef, 0x27, 0x77
    ];
  },
  {
    // Even
    coords = ?(
      0x79be667ef9dcbbac55a06295ce870b07029bfcdb2dce28d959f2815b16f81798,
      0x483ada7726a3c4655da4fbfc0e1108a8fd17b448a68554199c47d08ffb10d4b8,
    );
    compressed = [
      0x02, 0x79, 0xbe, 0x66, 0x7e, 0xf9, 0xdc, 0xbb, 0xac, 0x55, 0xa0, 0x62,
      0x95, 0xce, 0x87, 0x0b, 0x07, 0x02, 0x9b, 0xfc, 0xdb, 0x2d, 0xce, 0x28,
      0xd9, 0x59, 0xf2, 0x81, 0x5b, 0x16, 0xf8, 0x17, 0x98
    ];
    uncompressed = [
      0x04, 0x79, 0xbe, 0x66, 0x7e, 0xf9, 0xdc, 0xbb, 0xac, 0x55, 0xa0, 0x62,
      0x95, 0xce, 0x87, 0x0b, 0x07, 0x02, 0x9b, 0xfc, 0xdb, 0x2d, 0xce, 0x28,
      0xd9, 0x59, 0xf2, 0x81, 0x5b, 0x16, 0xf8, 0x17, 0x98, 0x48, 0x3a, 0xda,
      0x77, 0x26, 0xa3, 0xc4, 0x65, 0x5d, 0xa4, 0xfb, 0xfc, 0x0e, 0x11, 0x08,
      0xa8, 0xfd, 0x17, 0xb4, 0x48, 0xa6, 0x85, 0x54, 0x19, 0x9c, 0x47, 0xd0,
      0x8f, 0xfb, 0x10, 0xd4, 0xb8
    ];
  },
];

let fromBytesTestCases : [FromBytesTestCase] = [
  {
    coords = null;
    data = [];
  },
  {
    // Compressed Odd.
    coords = ?(
      0x79be667ef9dcbbac55a06295ce870b07029bfcdb2dce28d959f2815b16f81798,
      0xb7c52588d95c3b9aa25b0403f1eef75702e84bb7597aabe663b82f6f04ef2777,
    );
    data = [
      0x03, 0x79, 0xbe, 0x66, 0x7e, 0xf9, 0xdc, 0xbb, 0xac, 0x55, 0xa0, 0x62,
      0x95, 0xce, 0x87, 0x0b, 0x07, 0x02, 0x9b, 0xfc, 0xdb, 0x2d, 0xce, 0x28,
      0xd9, 0x59, 0xf2, 0x81, 0x5b, 0x16, 0xf8, 0x17, 0x98
    ];
  },
  {
    // Compressed Even.
    coords = ?(
      0x79be667ef9dcbbac55a06295ce870b07029bfcdb2dce28d959f2815b16f81798,
      0x483ada7726a3c4655da4fbfc0e1108a8fd17b448a68554199c47d08ffb10d4b8,
    );
    data = [
      0x02, 0x79, 0xbe, 0x66, 0x7e, 0xf9, 0xdc, 0xbb, 0xac, 0x55, 0xa0, 0x62,
      0x95, 0xce, 0x87, 0x0b, 0x07, 0x02, 0x9b, 0xfc, 0xdb, 0x2d, 0xce, 0x28,
      0xd9, 0x59, 0xf2, 0x81, 0x5b, 0x16, 0xf8, 0x17, 0x98
    ];
  },
  {
    // Uncompressed.
    coords = ?(
      0x79be667ef9dcbbac55a06295ce870b07029bfcdb2dce28d959f2815b16f81798,
      0x483ada7726a3c4655da4fbfc0e1108a8fd17b448a68554199c47d08ffb10d4b8,
    );
    data = [
      0x04, 0x79, 0xbe, 0x66, 0x7e, 0xf9, 0xdc, 0xbb, 0xac, 0x55, 0xa0, 0x62,
      0x95, 0xce, 0x87, 0x0b, 0x07, 0x02, 0x9b, 0xfc, 0xdb, 0x2d, 0xce, 0x28,
      0xd9, 0x59, 0xf2, 0x81, 0x5b, 0x16, 0xf8, 0x17, 0x98, 0x48, 0x3a, 0xda,
      0x77, 0x26, 0xa3, 0xc4, 0x65, 0x5d, 0xa4, 0xfb, 0xfc, 0x0e, 0x11, 0x08,
      0xa8, 0xfd, 0x17, 0xb4, 0x48, 0xa6, 0x85, 0x54, 0x19, 0x9c, 0x47, 0xd0,
      0x8f, 0xfb, 0x10, 0xd4, 0xb8
    ];
  },
  {
    // Not on curve.
    coords = null;
    data = [
      0x04, 0x79, 0xbe, 0x66, 0x7e, 0xf9, 0xdc, 0xbb, 0xac, 0x55, 0xa0, 0x62,
      0x95, 0xce, 0x87, 0x0b, 0x07, 0x02, 0x9b, 0xfc, 0xdb, 0x2d, 0xce, 0x28,
      0xd9, 0x59, 0xf2, 0x81, 0x5b, 0x16, 0xf8, 0x17, 0x98, 0x00, 0x00, 0x00,
      0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
      0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
      0x00, 0x00, 0x00, 0x00, 0x00
    ];
  },
  {
    // Invalid data.
    coords = null;
    data = [
      0x04, 0x79, 0xbe, 0x66, 0x7e, 0xf9, 0xdc, 0xbb, 0xac, 0x55, 0xa0, 0x62,
      0x95, 0xce, 0x87, 0x0b, 0x07, 0x02, 0x9b, 0xfc, 0xdb, 0x2d, 0xce, 0x28,
      0xd9, 0x59, 0xf2, 0x81, 0x5b, 0x16, 0xf8, 0x17, 0x98
    ];
  },
  {
    // Invalid data.
    coords = null;
    data = [
      0x02
    ];
  },
  {
    // Invalid data.
    coords = null;
    data = [
      0x03
    ];
  },
  {
    // Invalid data.
    coords = null;
    data = [
      0x04
    ];
  },
];

func testFromBytes(testCase : FromBytesTestCase) {
  let actualPoint = Affine.fromBytes(testCase.data, curve);
  switch (testCase.coords, actualPoint) {
    case (null, null) {
      // ok
    };
    case (?coords, ?actualPoint) {
      let expectedPoint = #point (Fp(coords.0), Fp(coords.1), curve);
      assert(Affine.isEqual(expectedPoint, actualPoint));
    };
    case _ {
      assert(false);
    };
  };
};

func testToBytes(testCase : ToBytesTestCase) {
  let point = switch (testCase.coords) {
    case (null) {
      #infinity(curve)
    };
    case (?coords) {
      #point (Fp(coords.0), Fp(coords.1), curve);
    };
  };
  let actualCompressed = Affine.toBytes(point, true);
  let actualUncompressed = Affine.toBytes(point, false);

  assert(testCase.compressed == actualCompressed);
  assert(testCase.uncompressed == actualUncompressed);
};

Debug.print("Affine tests");

let runTest = TestUtils.runTestWithDefaults;

runTest({
  title = "FromBytes";
  fn = testFromBytes;
  vectors = fromBytesTestCases;
});

runTest({
  title = "ToBytes";
  fn = testToBytes;
  vectors = toBytesTestCases;
});
